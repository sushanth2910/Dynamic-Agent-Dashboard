{"version":3,"file":"vega-selection.min.js","sources":["../../../node_modules/d3-array/src/ascending.js","../../../node_modules/d3-array/src/descending.js","../../../node_modules/d3-array/src/bisector.js","../../../node_modules/internmap/src/index.js","../../../node_modules/d3-array/src/intersection.js","../src/util.js","../src/selectionTest.js","../src/selectionResolve.js","../../../node_modules/d3-array/src/union.js","../src/selectionTuples.js","../src/selectionVisitor.js"],"sourcesContent":["export default function ascending(a, b) {\n  return a == null || b == null ? NaN : a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n}\n","export default function descending(a, b) {\n  return a == null || b == null ? NaN\n    : b < a ? -1\n    : b > a ? 1\n    : b >= a ? 0\n    : NaN;\n}\n","import ascending from \"./ascending.js\";\nimport descending from \"./descending.js\";\n\nexport default function bisector(f) {\n  let compare1, compare2, delta;\n\n  // If an accessor is specified, promote it to a comparator. In this case we\n  // can test whether the search value is (self-) comparable. We can’t do this\n  // for a comparator (except for specific, known comparators) because we can’t\n  // tell if the comparator is symmetric, and an asymmetric comparator can’t be\n  // used to test whether a single value is comparable.\n  if (f.length !== 2) {\n    compare1 = ascending;\n    compare2 = (d, x) => ascending(f(d), x);\n    delta = (d, x) => f(d) - x;\n  } else {\n    compare1 = f === ascending || f === descending ? f : zero;\n    compare2 = f;\n    delta = f;\n  }\n\n  function left(a, x, lo = 0, hi = a.length) {\n    if (lo < hi) {\n      if (compare1(x, x) !== 0) return hi;\n      do {\n        const mid = (lo + hi) >>> 1;\n        if (compare2(a[mid], x) < 0) lo = mid + 1;\n        else hi = mid;\n      } while (lo < hi);\n    }\n    return lo;\n  }\n\n  function right(a, x, lo = 0, hi = a.length) {\n    if (lo < hi) {\n      if (compare1(x, x) !== 0) return hi;\n      do {\n        const mid = (lo + hi) >>> 1;\n        if (compare2(a[mid], x) <= 0) lo = mid + 1;\n        else hi = mid;\n      } while (lo < hi);\n    }\n    return lo;\n  }\n\n  function center(a, x, lo = 0, hi = a.length) {\n    const i = left(a, x, lo, hi - 1);\n    return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;\n  }\n\n  return {left, center, right};\n}\n\nfunction zero() {\n  return 0;\n}\n","export class InternMap extends Map {\n  constructor(entries, key = keyof) {\n    super();\n    Object.defineProperties(this, {_intern: {value: new Map()}, _key: {value: key}});\n    if (entries != null) for (const [key, value] of entries) this.set(key, value);\n  }\n  get(key) {\n    return super.get(intern_get(this, key));\n  }\n  has(key) {\n    return super.has(intern_get(this, key));\n  }\n  set(key, value) {\n    return super.set(intern_set(this, key), value);\n  }\n  delete(key) {\n    return super.delete(intern_delete(this, key));\n  }\n}\n\nexport class InternSet extends Set {\n  constructor(values, key = keyof) {\n    super();\n    Object.defineProperties(this, {_intern: {value: new Map()}, _key: {value: key}});\n    if (values != null) for (const value of values) this.add(value);\n  }\n  has(value) {\n    return super.has(intern_get(this, value));\n  }\n  add(value) {\n    return super.add(intern_set(this, value));\n  }\n  delete(value) {\n    return super.delete(intern_delete(this, value));\n  }\n}\n\nfunction intern_get({_intern, _key}, value) {\n  const key = _key(value);\n  return _intern.has(key) ? _intern.get(key) : value;\n}\n\nfunction intern_set({_intern, _key}, value) {\n  const key = _key(value);\n  if (_intern.has(key)) return _intern.get(key);\n  _intern.set(key, value);\n  return value;\n}\n\nfunction intern_delete({_intern, _key}, value) {\n  const key = _key(value);\n  if (_intern.has(key)) {\n    value = _intern.get(key);\n    _intern.delete(key);\n  }\n  return value;\n}\n\nfunction keyof(value) {\n  return value !== null && typeof value === \"object\" ? value.valueOf() : value;\n}\n","import {InternSet} from \"internmap\";\n\nexport default function intersection(values, ...others) {\n  values = new InternSet(values);\n  others = others.map(set);\n  out: for (const value of values) {\n    for (const other of others) {\n      if (!other.has(value)) {\n        values.delete(value);\n        continue out;\n      }\n    }\n  }\n  return values;\n}\n\nfunction set(values) {\n  return values instanceof InternSet ? values : new InternSet(values);\n}\n","import {field} from 'vega-util';\n\n// Registers vega-util field accessors to protect against XSS attacks\nconst SELECTION_GETTER = Symbol('vega_selection_getter');\nexport function getter(f) {\n  if (!f.getter || !f.getter[SELECTION_GETTER]) {\n    f.getter = field(f.field);\n    f.getter[SELECTION_GETTER] = true;\n  }\n\n  return f.getter;\n}\n\nexport const Intersect = 'intersect';\nexport const Union = 'union';\nexport const VlMulti = 'vlMulti';\nexport const VlPoint = 'vlPoint';\nexport const Or = 'or';\nexport const And = 'and';\n\nexport const SelectionId = '_vgsid_';\nexport const $selectionId = field(SelectionId);\n","import {bisector} from 'd3-array';\nimport {inrange, isArray, isDate, toNumber} from 'vega-util';\nimport {$selectionId, Intersect, getter} from './util';\n\nconst TYPE_ENUM = 'E',\n    TYPE_RANGE_INC = 'R',\n    TYPE_RANGE_EXC = 'R-E',\n    TYPE_RANGE_LE = 'R-LE',\n    TYPE_RANGE_RE = 'R-RE',\n    TYPE_PRED_LT = 'E-LT',\n    TYPE_PRED_LTE = 'E-LTE',\n    TYPE_PRED_GT = 'E-GT',\n    TYPE_PRED_GTE = 'E-GTE',\n    TYPE_PRED_VALID = 'E-VALID',\n    TYPE_PRED_ONE_OF = 'E-ONE',\n    UNIT_INDEX = 'index:unit';\n\n// TODO: revisit date coercion?\nfunction testPoint(datum, entry) {\n  var fields = entry.fields,\n      values = entry.values,\n      n = fields.length,\n      i = 0, dval, f;\n\n  for (; i<n; ++i) {\n    f = fields[i];\n    dval = getter(f)(datum);\n\n    if (isDate(dval)) dval = toNumber(dval);\n    if (isDate(values[i])) values[i] = toNumber(values[i]);\n    if (isArray(values[i]) && isDate(values[i][0])) values[i] = values[i].map(toNumber);\n\n    if (f.type === TYPE_ENUM) {\n      // Enumerated fields can either specify individual values (single/multi selections)\n      // or an array of values (interval selections).\n      if(isArray(values[i]) ? !values[i].includes(dval) : dval !== values[i]) {\n        return false;\n      }\n    } else {\n      if (f.type === TYPE_RANGE_INC) {\n        if (!inrange(dval, values[i])) return false;\n      } else if (f.type === TYPE_RANGE_RE) {\n        // Discrete selection of bins test within the range [bin_start, bin_end).\n        if (!inrange(dval, values[i], true, false)) return false;\n      } else if (f.type === TYPE_RANGE_EXC) { // 'R-E'/'R-LE' included for completeness.\n        if (!inrange(dval, values[i], false, false)) return false;\n      } else if (f.type === TYPE_RANGE_LE) {\n        if (!inrange(dval, values[i], false, true)) return false;\n      } else if (f.type === TYPE_PRED_LT) {\n        if (dval >= values[i]) return false;\n      } else if (f.type === TYPE_PRED_LTE) {\n        if (dval > values[i]) return false;\n      } else if (f.type === TYPE_PRED_GT) {\n        if (dval <= values[i]) return false;\n      } else if (f.type === TYPE_PRED_GTE) {\n        if (dval < values[i]) return false;\n      } else if (f.type === TYPE_PRED_VALID) {\n        if (dval === null || isNaN(dval)) return false;\n      } else if (f.type === TYPE_PRED_ONE_OF) {\n        if (values[i].indexOf(dval) === -1) return false;\n      }\n    }\n  }\n\n  return true;\n}\n\n/**\n * Tests if a tuple is contained within an interactive selection.\n * @param {string} name - The name of the data set representing the selection.\n *  Tuples in the dataset are of the form\n *  {unit: string, fields: array<fielddef>, values: array<*>}.\n *  Fielddef is of the form\n *  {field: string, channel: string, type: 'E' | 'R'} where\n *  'type' identifies whether tuples in the dataset enumerate\n *  values for the field, or specify a continuous range.\n * @param {object} datum - The tuple to test for inclusion.\n * @param {string} op - The set operation for combining selections.\n *   One of 'intersect' or 'union' (default).\n * @return {boolean} - True if the datum is in the selection, false otherwise.\n */\nexport function selectionTest(name, datum, op) {\n  var data = this.context.data[name],\n      entries = data ? data.values.value : [],\n      unitIdx = data ? data[UNIT_INDEX] && data[UNIT_INDEX].value : undefined,\n      intersect = op === Intersect,\n      n = entries.length,\n      i = 0,\n      entry, miss, count, unit, b;\n\n  for (; i<n; ++i) {\n    entry = entries[i];\n\n    if (unitIdx && intersect) {\n      // multi selections union within the same unit and intersect across units.\n      miss = miss || {};\n      count = miss[unit=entry.unit] || 0;\n\n      // if we've already matched this unit, skip.\n      if (count === -1) continue;\n\n      b = testPoint(datum, entry);\n      miss[unit] = b ? -1 : ++count;\n\n      // if we match and there are no other units return true\n      // if we've missed against all tuples in this unit return false\n      if (b && unitIdx.size === 1) return true;\n      if (!b && count === unitIdx.get(unit).count) return false;\n    } else {\n      b = testPoint(datum, entry);\n\n      // if we find a miss and we do require intersection return false\n      // if we find a match and we don't require intersection return true\n      if (intersect ^ b) return b;\n    }\n  }\n\n  // if intersecting and we made it here, then we saw no misses\n  // if not intersecting, then we saw no matches\n  // if no active selections, return false\n  return n && intersect;\n}\n\nconst bisect = bisector($selectionId),\n  bisectLeft = bisect.left,\n  bisectRight = bisect.right;\n\nexport function selectionIdTest(name, datum, op) {\n  const data = this.context.data[name],\n      entries = data ? data.values.value : [],\n      unitIdx = data ? data[UNIT_INDEX] && data[UNIT_INDEX].value : undefined,\n      intersect = op === Intersect,\n      value = $selectionId(datum),\n      index = bisectLeft(entries, value);\n\n  if (index === entries.length) return false;\n  if ($selectionId(entries[index]) !== value) return false;\n\n  if (unitIdx && intersect) {\n    if (unitIdx.size === 1) return true;\n    if (bisectRight(entries, value) - index < unitIdx.size) return false;\n  }\n\n  return true;\n}\n","import {intersection, union} from 'd3-array';\nimport {array, toNumber} from 'vega-util';\nimport {$selectionId, And, Or, SelectionId, Union, VlMulti, VlPoint} from './util';\n\n/**\n * Resolves selection for use as a scale domain or reads via the API.\n * @param {string} name - The name of the dataset representing the selection\n * @param {string} [op='union'] - The set operation for combining selections.\n *                 One of 'intersect' or 'union' (default).\n * @param {boolean} isMulti - Identifies a \"multi\" selection to perform more\n *                 expensive resolution computation.\n * @param {boolean} vl5 - With Vega-Lite v5, \"multi\" selections are now called \"point\"\n *                 selections, and thus the resolved tuple should reflect this name.\n *                 This parameter allows us to reflect this change without triggering\n *                 a major version bump for Vega.\n * @returns {object} An object of selected fields and values.\n */\nexport function selectionResolve(name, op, isMulti, vl5) {\n  var data = this.context.data[name],\n    entries = data ? data.values.value : [],\n    resolved = {}, multiRes = {}, types = {},\n    entry, fields, values, unit, field, value, res, resUnit, type, union,\n    n = entries.length, i = 0, j, m;\n\n  // First union all entries within the same unit.\n  for (; i < n; ++i) {\n    entry = entries[i];\n    unit = entry.unit;\n    fields = entry.fields;\n    values = entry.values;\n\n    if (fields && values) { // Intentional selection stores\n      for (j = 0, m = fields.length; j < m; ++j) {\n        field = fields[j];\n        res = resolved[field.field] || (resolved[field.field] = {});\n        resUnit = res[unit] || (res[unit] = []);\n        types[field.field] = type = field.type.charAt(0);\n        union = ops[`${type}_union`];\n        res[unit] = union(resUnit, array(values[j]));\n      }\n\n      // If the same multi-selection is repeated over views and projected over\n      // an encoding, it may operate over different fields making it especially\n      // tricky to reliably resolve it. At best, we can de-dupe identical entries\n      // but doing so may be more computationally expensive than it is worth.\n      // Instead, for now, we simply transform our store representation into\n      // a more human-friendly one.\n      if (isMulti) {\n        resUnit = multiRes[unit] || (multiRes[unit] = []);\n        resUnit.push(array(values).reduce((obj, curr, j) => (obj[fields[j].field] = curr, obj), {}));\n      }\n    } else {  // Short circuit extensional selectionId stores which hold sorted IDs unique to each unit.\n      field = SelectionId;\n      value = $selectionId(entry);\n      res = resolved[field] || (resolved[field] = {});\n      resUnit = res[unit] || (res[unit] = []);\n      resUnit.push(value);\n\n      if (isMulti) {\n        resUnit = multiRes[unit] || (multiRes[unit] = []);\n        resUnit.push({[SelectionId]: value});\n      }\n    }\n  }\n\n  // Then resolve fields across units as per the op.\n  op = op || Union;\n  if (resolved[SelectionId]) {\n    resolved[SelectionId] = ops[`${SelectionId}_${op}`](...Object.values(resolved[SelectionId]));\n  } else {\n    Object.keys(resolved).forEach(field => {\n      resolved[field] = Object.keys(resolved[field])\n        .map(unit => resolved[field][unit])\n        .reduce((acc, curr) => acc === undefined ? curr : ops[`${types[field]}_${op}`](acc, curr));\n    });\n  }\n\n  entries = Object.keys(multiRes);\n  if (isMulti && entries.length) {\n    const key = vl5 ? VlPoint : VlMulti;\n    resolved[key] = op === Union\n      ? {[Or]: entries.reduce((acc, k) => (acc.push(...multiRes[k]), acc), [])}\n      : {[And]: entries.map(k => ({[Or]: multiRes[k]}))};\n  }\n\n  return resolved;\n}\n\nvar ops = {\n  [`${SelectionId}_union`]: union,\n  [`${SelectionId}_intersect`]: intersection,\n\n  E_union: function(base, value) {\n    if (!base.length) return value;\n\n    var i = 0, n = value.length;\n    for (; i<n; ++i) if (!base.includes(value[i])) base.push(value[i]);\n    return base;\n  },\n\n  E_intersect: function(base, value) {\n    return !base.length ? value :\n      base.filter(v => value.includes(v));\n  },\n\n  R_union: function(base, value) {\n    var lo = toNumber(value[0]), hi = toNumber(value[1]);\n    if (lo > hi) {\n      lo = value[1];\n      hi = value[0];\n    }\n\n    if (!base.length) return [lo, hi];\n    if (base[0] > lo) base[0] = lo;\n    if (base[1] < hi) base[1] = hi;\n    return base;\n  },\n\n  R_intersect: function(base, value) {\n    var lo = toNumber(value[0]), hi = toNumber(value[1]);\n    if (lo > hi) {\n      lo = value[1];\n      hi = value[0];\n    }\n\n    if (!base.length) return [lo, hi];\n    if (hi < base[0] || base[1] < lo) {\n      return [];\n    } else {\n      if (base[0] < lo) base[0] = lo;\n      if (base[1] > hi) base[1] = hi;\n    }\n    return base;\n  }\n};\n","import {InternSet} from \"internmap\";\n\nexport default function union(...others) {\n  const set = new InternSet();\n  for (const other of others) {\n    for (const o of other) {\n      set.add(o);\n    }\n  }\n  return set;\n}\n","import {extend} from 'vega-util';\nimport {$selectionId, SelectionId, getter} from './util';\nimport {error, isArray, isObject} from 'vega-util';\n\n/**\n * Maps an array of scene graph items to an array of selection tuples.\n * @param {array} array - Input scene graph items\n * @param {object} base - The base object that generated tuples extend.\n *\n * @returns {array} An array of selection entries for the given unit.\n */\nexport function selectionTuples(array, base) {\n  if (!isArray(array)) {\n    error('First argument to selectionTuples must be an array.');\n  }\n  if (!isObject(base)) {\n    error('Second argument to selectionTuples must be an object.');\n  }\n  return array.map(x => extend(\n    base.fields ? {\n      values: base.fields.map(f => getter(f)(x.datum))\n    } : {\n      [SelectionId]: $selectionId(x.datum)\n    }, base));\n}\n","import {Literal} from 'vega-expression';\nimport {error, hasOwnProperty, peek} from 'vega-util';\nimport {Intersect} from './util';\n\nconst DataPrefix = ':',\n      IndexPrefix = '@';\n\nexport function selectionVisitor(name, args, scope, params) {\n  if (args[0].type !== Literal) error('First argument to selection functions must be a string literal.');\n\n  const data = args[0].value,\n        op = args.length >= 2 && peek(args).value,\n        field = 'unit',\n        indexName = IndexPrefix + field,\n        dataName = DataPrefix + data;\n\n  // eslint-disable-next-line no-prototype-builtins\n  if (op === Intersect && !hasOwnProperty(params, indexName)) {\n    params[indexName] = scope.getData(data).indataRef(scope, field);\n  }\n\n  // eslint-disable-next-line no-prototype-builtins\n  if (!hasOwnProperty(params, dataName)) {\n    params[dataName] = scope.getData(data).tuplesRef();\n  }\n}\n"],"names":["ascending","a","b","NaN","descending","zero","InternSet","Set","constructor","values","key","keyof","super","Object","defineProperties","this","_intern","value","Map","_key","add","has","get","intern_get","set","intern_set","delete","intern_delete","valueOf","SELECTION_GETTER","Symbol","getter","f","field","Intersect","Union","Or","And","SelectionId","$selectionId","UNIT_INDEX","testPoint","datum","entry","dval","fields","n","length","i","isDate","toNumber","isArray","map","type","includes","inrange","isNaN","indexOf","bisect","compare1","compare2","delta","left","x","lo","hi","mid","d","center","right","bisector","bisectLeft","bisectRight","ops","others","other","o","out","E_union","base","push","E_intersect","filter","v","R_union","R_intersect","name","op","data","context","entries","unitIdx","undefined","intersect","index","size","isMulti","vl5","unit","res","resUnit","union","j","m","resolved","multiRes","types","charAt","array","reduce","obj","curr","keys","forEach","acc","k","miss","count","error","isObject","extend","args","scope","params","Literal","indexName","dataName","peek","hasOwnProperty","getData","indataRef","tuplesRef"],"mappings":"4UAAe,SAASA,EAAUC,EAAGC,GACnC,OAAY,MAALD,GAAkB,MAALC,EAAYC,IAAMF,EAAIC,GAAI,EAAKD,EAAIC,EAAI,EAAID,GAAKC,EAAI,EAAIC,GAC9E,CCFe,SAASC,EAAWH,EAAGC,GACpC,OAAY,MAALD,GAAkB,MAALC,EAAYC,IAC5BD,EAAID,GAAI,EACRC,EAAID,EAAI,EACRC,GAAKD,EAAI,EACTE,GACN,CC+CA,SAASE,IACP,OAAO,CACT,CCnCO,MAAMC,UAAkBC,IAC7BC,WAAAA,CAAYC,EAAQC,EAAMC,GAGxB,GAFAC,QACAC,OAAOC,iBAAiBC,KAAM,CAACC,QAAS,CAACC,MAAO,IAAIC,KAAQC,KAAM,CAACF,MAAOP,KAC5D,MAAVD,EAAgB,IAAK,MAAMQ,KAASR,EAAQM,KAAKK,IAAIH,EAC3D,CACAI,GAAAA,CAAIJ,GACF,OAAOL,MAAMS,IAUjB,UAAoBL,QAACA,EAAOG,KAAEA,GAAOF,GACnC,MAAMP,EAAMS,EAAKF,GACjB,OAAOD,EAAQK,IAAIX,GAAOM,EAAQM,IAAIZ,GAAOO,CAC/C,CAbqBM,CAAWR,KAAME,GACpC,CACAG,GAAAA,CAAIH,GACF,OAAOL,MAAMQ,IAYjB,UAAoBJ,QAACA,EAAOG,KAAEA,GAAOF,GACnC,MAAMP,EAAMS,EAAKF,GACjB,OAAID,EAAQK,IAAIX,GAAaM,EAAQM,IAAIZ,IACzCM,EAAQQ,IAAId,EAAKO,GACVA,EACT,CAjBqBQ,CAAWV,KAAME,GACpC,CACAS,OAAOT,GACL,OAAOL,MAAMc,OAgBjB,UAAuBV,QAACA,EAAOG,KAAEA,GAAOF,GACtC,MAAMP,EAAMS,EAAKF,GACbD,EAAQK,IAAIX,KACdO,EAAQD,EAAQM,IAAIZ,GACpBM,EAAQU,OAAOhB,IAEjB,OAAOO,CACT,CAvBwBU,CAAcZ,KAAME,GAC1C,EAwBF,SAASN,EAAMM,GACb,OAAiB,OAAVA,GAAmC,iBAAVA,EAAqBA,EAAMW,UAAYX,CACzE,CC5CA,SAASO,EAAIf,GACX,OAAOA,aAAkBH,EAAYG,EAAS,IAAIH,EAAUG,EAC9D,CCfA,MAAMoB,EAAmBC,OAAO,yBACzB,SAASC,EAAOC,GAMrB,OALKA,EAAED,QAAWC,EAAED,OAAOF,KACzBG,EAAED,OAASE,QAAMD,EAAEC,OACnBD,EAAED,OAAOF,IAAoB,GAGxBG,EAAED,MACX,CAEO,MAAMG,EAAY,YACZC,EAAQ,QAGRC,EAAK,KACLC,EAAM,MAENC,EAAc,UACdC,EAAeN,EAAAA,MAAMK,GCN9BE,EAAa,aAGjB,SAASC,EAAUC,EAAOC,GAMxB,IALA,IAGWC,EAAMZ,EAHba,EAASF,EAAME,OACfpC,EAASkC,EAAMlC,OACfqC,EAAID,EAAOE,OACXC,EAAI,EAEDA,EAAEF,IAAKE,EAQZ,GANAJ,EAAOb,EADPC,EAAIa,EAAOG,GACJjB,CAAUW,GAEbO,EAAAA,OAAOL,KAAOA,EAAOM,EAAAA,SAASN,IAC9BK,SAAOxC,EAAOuC,MAAKvC,EAAOuC,GAAKE,EAAAA,SAASzC,EAAOuC,KAC/CG,EAAAA,QAAQ1C,EAAOuC,KAAOC,EAAAA,OAAOxC,EAAOuC,GAAG,MAAKvC,EAAOuC,GAAKvC,EAAOuC,GAAGI,IAAIF,aA1B5D,MA4BVlB,EAAEqB,MAGJ,GAAGF,EAAAA,QAAQ1C,EAAOuC,KAAOvC,EAAOuC,GAAGM,SAASV,GAAQA,IAASnC,EAAOuC,GAClE,OAAO,OAGT,GAlCe,MAkCXhB,EAAEqB,MACJ,IAAKE,EAAAA,QAAQX,EAAMnC,EAAOuC,IAAK,OAAO,OACjC,GAjCO,SAiCHhB,EAAEqB,MAEX,IAAKE,EAAAA,QAAQX,EAAMnC,EAAOuC,IAAI,GAAM,GAAQ,OAAO,OAC9C,GAtCQ,QAsCJhB,EAAEqB,MACX,IAAKE,EAAAA,QAAQX,EAAMnC,EAAOuC,IAAI,GAAO,GAAQ,OAAO,OAC/C,GAvCO,SAuCHhB,EAAEqB,MACX,IAAKE,EAAAA,QAAQX,EAAMnC,EAAOuC,IAAI,GAAO,GAAO,OAAO,OAC9C,GAvCM,SAuCFhB,EAAEqB,MACX,GAAIT,GAAQnC,EAAOuC,GAAI,OAAO,OACzB,GAxCO,UAwCHhB,EAAEqB,MACX,GAAIT,EAAOnC,EAAOuC,GAAI,OAAO,OACxB,GAzCM,SAyCFhB,EAAEqB,MACX,GAAIT,GAAQnC,EAAOuC,GAAI,OAAO,OACzB,GA1CO,UA0CHhB,EAAEqB,MACX,GAAIT,EAAOnC,EAAOuC,GAAI,OAAO,OACxB,GA3CS,YA2CLhB,EAAEqB,MACX,GAAa,OAATT,GAAiBY,MAAMZ,GAAO,OAAO,OACpC,GA5CU,UA4CNZ,EAAEqB,OACqB,IAA5B5C,EAAOuC,GAAGS,QAAQb,GAAc,OAAO,EAKjD,OAAO,CACT,CA0DA,MAAMc,EJxHS,SAAkB1B,GAC/B,IAAI2B,EAAUC,EAAUC,EAiBxB,SAASC,EAAK7D,EAAG8D,EAAGC,EAAK,EAAGC,EAAKhE,EAAE8C,QACjC,GAAIiB,EAAKC,EAAI,CACX,GAAuB,IAAnBN,EAASI,EAAGA,GAAU,OAAOE,EACjC,EAAG,CACD,MAAMC,EAAOF,EAAKC,IAAQ,EACtBL,EAAS3D,EAAEiE,GAAMH,GAAK,EAAGC,EAAKE,EAAM,EACnCD,EAAKC,CACZ,OAASF,EAAKC,EAChB,CACA,OAAOD,CACT,CAmBA,OAvCiB,IAAbhC,EAAEe,QACJY,EAAW3D,EACX4D,EAAWA,CAACO,EAAGJ,IAAM/D,EAAUgC,EAAEmC,GAAIJ,GACrCF,EAAQA,CAACM,EAAGJ,IAAM/B,EAAEmC,GAAKJ,IAEzBJ,EAAW3B,IAAMhC,GAAagC,IAAM5B,EAAa4B,EAAI3B,EACrDuD,EAAW5B,EACX6B,EAAQ7B,GAgCH,CAAC8B,OAAMM,OALd,SAAgBnE,EAAG8D,EAAGC,EAAK,EAAGC,EAAKhE,EAAE8C,QACnC,MAAMC,EAAIc,EAAK7D,EAAG8D,EAAGC,EAAIC,EAAK,GAC9B,OAAOjB,EAAIgB,GAAMH,EAAM5D,EAAE+C,EAAI,GAAIe,IAAMF,EAAM5D,EAAE+C,GAAIe,GAAKf,EAAI,EAAIA,CAClE,EAEsBqB,MAjBtB,SAAepE,EAAG8D,EAAGC,EAAK,EAAGC,EAAKhE,EAAE8C,QAClC,GAAIiB,EAAKC,EAAI,CACX,GAAuB,IAAnBN,EAASI,EAAGA,GAAU,OAAOE,EACjC,EAAG,CACD,MAAMC,EAAOF,EAAKC,IAAQ,EACtBL,EAAS3D,EAAEiE,GAAMH,IAAM,EAAGC,EAAKE,EAAM,EACpCD,EAAKC,CACZ,OAASF,EAAKC,EAChB,CACA,OAAOD,CACT,EAQF,CIwEeM,CAAS/B,GACtBgC,EAAab,EAAOI,KACpBU,EAAcd,EAAOW,MCrCvB,IAAII,EAAM,CACR,CAAC,GAAGnC,WCvFS,YAAkBoC,GAC/B,MAAMlD,EAAM,IAAIlB,EAChB,IAAK,MAAMqE,KAASD,EAClB,IAAK,MAAME,KAAKD,EACdnD,EAAIJ,IAAIwD,GAGZ,OAAOpD,CACT,EDgFE,CAAC,GAAGc,eHxFS,SAAsB7B,KAAWiE,GAC9CjE,EAAS,IAAIH,EAAUG,GACvBiE,EAASA,EAAOtB,IAAI5B,GACpBqD,EAAK,IAAK,MAAM5D,KAASR,EACvB,IAAK,MAAMkE,KAASD,EAClB,IAAKC,EAAMtD,IAAIJ,GAAQ,CACrBR,EAAOiB,OAAOT,GACd,SAAS4D,CACX,CAGJ,OAAOpE,CACT,EG8EEqE,QAAS,SAASC,EAAM9D,GACtB,IAAK8D,EAAKhC,OAAQ,OAAO9B,EAGzB,IADA,IAAI+B,EAAI,EAAGF,EAAI7B,EAAM8B,OACdC,EAAEF,IAAKE,EAAQ+B,EAAKzB,SAASrC,EAAM+B,KAAK+B,EAAKC,KAAK/D,EAAM+B,IAC/D,OAAO+B,CACT,EAEAE,YAAa,SAASF,EAAM9D,GAC1B,OAAQ8D,EAAKhC,OACXgC,EAAKG,QAAOC,GAAKlE,EAAMqC,SAAS6B,KADZlE,CAExB,EAEAmE,QAAS,SAASL,EAAM9D,GACtB,IAAI+C,EAAKd,EAAAA,SAASjC,EAAM,IAAKgD,EAAKf,EAAAA,SAASjC,EAAM,IAMjD,OALI+C,EAAKC,IACPD,EAAK/C,EAAM,GACXgD,EAAKhD,EAAM,IAGR8D,EAAKhC,QACNgC,EAAK,GAAKf,IAAIe,EAAK,GAAKf,GACxBe,EAAK,GAAKd,IAAIc,EAAK,GAAKd,GACrBc,GAHkB,CAACf,EAAIC,EAIhC,EAEAoB,YAAa,SAASN,EAAM9D,GAC1B,IAAI+C,EAAKd,EAAAA,SAASjC,EAAM,IAAKgD,EAAKf,EAAAA,SAASjC,EAAM,IAMjD,OALI+C,EAAKC,IACPD,EAAK/C,EAAM,GACXgD,EAAKhD,EAAM,IAGR8D,EAAKhC,OACNkB,EAAKc,EAAK,IAAMA,EAAK,GAAKf,EACrB,IAEHe,EAAK,GAAKf,IAAIe,EAAK,GAAKf,GACxBe,EAAK,GAAKd,IAAIc,EAAK,GAAKd,GAEvBc,GAPkB,CAACf,EAAIC,EAQhC,qBDNK,SAAyBqB,EAAM5C,EAAO6C,GAC3C,MAAMC,EAAOzE,KAAK0E,QAAQD,KAAKF,GAC3BI,EAAUF,EAAOA,EAAK/E,OAAOQ,MAAQ,GACrC0E,EAAUH,EAAOA,EAAKhD,IAAegD,EAAKhD,GAAYvB,WAAQ2E,EAC9DC,EAAYN,IAAOrD,EACnBjB,EAAQsB,EAAaG,GACrBoD,EAAQvB,EAAWmB,EAASzE,GAEhC,GAAI6E,IAAUJ,EAAQ3C,OAAQ,OAAO,EACrC,GAAIR,EAAamD,EAAQI,MAAY7E,EAAO,OAAO,EAEnD,GAAI0E,GAAWE,EAAW,CACxB,GAAqB,IAAjBF,EAAQI,KAAY,OAAO,EAC/B,GAAIvB,EAAYkB,EAASzE,GAAS6E,EAAQH,EAAQI,KAAM,OAAO,CACjE,CAEA,OAAO,CACT,qBC/HO,SAA0BT,EAAMC,EAAIS,EAASC,GAQlD,IAPA,IAGEtD,EAAOE,EAAQpC,EAAQyF,EAAMjE,EAAOhB,EAAOkF,EAAKC,EAAS/C,EAAMgD,EACpCC,EAAGC,EAJ5Bf,EAAOzE,KAAK0E,QAAQD,KAAKF,GAC3BI,EAAUF,EAAOA,EAAK/E,OAAOQ,MAAQ,GACrCuF,EAAW,CAAA,EAAIC,EAAW,CAAA,EAAIC,EAAQ,CAAA,EAEtC5D,EAAI4C,EAAQ3C,OAAQC,EAAI,EAGnBA,EAAIF,IAAKE,EAMd,GAJAkD,GADAvD,EAAQ+C,EAAQ1C,IACHkD,KACbrD,EAASF,EAAME,OACfpC,EAASkC,EAAMlC,OAEXoC,GAAUpC,EAAQ,CACpB,IAAK6F,EAAI,EAAGC,EAAI1D,EAAOE,OAAQuD,EAAIC,IAAKD,EACtCrE,EAAQY,EAAOyD,GAEfF,GADAD,EAAMK,EAASvE,EAAMA,SAAWuE,EAASvE,EAAMA,OAAS,KAC1CiE,KAAUC,EAAID,GAAQ,IACpCQ,EAAMzE,EAAMA,OAASoB,EAAOpB,EAAMoB,KAAKsD,OAAO,GAC9CN,EAAQ5B,EAAI,GAAGpB,WACf8C,EAAID,GAAQG,EAAMD,EAASQ,EAAAA,MAAMnG,EAAO6F,KAStCN,IACFI,EAAUK,EAASP,KAAUO,EAASP,GAAQ,KACtClB,KAAK4B,QAAMnG,GAAQoG,QAAO,CAACC,EAAKC,EAAMT,KAAOQ,EAAIjE,EAAOyD,GAAGrE,OAAS8E,EAAMD,IAAM,CAAA,GAE5F,MACE7E,EAAQK,EACRrB,EAAQsB,EAAaI,IAErByD,GADAD,EAAMK,EAASvE,KAAWuE,EAASvE,GAAS,KAC9BiE,KAAUC,EAAID,GAAQ,KAC5BlB,KAAK/D,GAET+E,IACFI,EAAUK,EAASP,KAAUO,EAASP,GAAQ,KACtClB,KAAK,CAAC1C,CAACA,GAAcrB,IAkBnC,GAZAsE,EAAKA,GAAMpD,EACPqE,EAASlE,GACXkE,EAASlE,GAAemC,EAAI,GAAGnC,KAAeiD,QAAS1E,OAAOJ,OAAO+F,EAASlE,KAE9EzB,OAAOmG,KAAKR,GAAUS,SAAQhF,IAC5BuE,EAASvE,GAASpB,OAAOmG,KAAKR,EAASvE,IACpCmB,KAAI8C,GAAQM,EAASvE,GAAOiE,KAC5BW,QAAO,CAACK,EAAKH,SAAiBnB,IAARsB,EAAoBH,EAAOtC,EAAI,GAAGiC,EAAMzE,MAAUsD,KAAM2B,EAAKH,IAAM,IAIhGrB,EAAU7E,OAAOmG,KAAKP,GAClBT,GAAWN,EAAQ3C,OAAQ,CAE7ByD,EADYP,EF/DO,UADA,WEiEHV,IAAOpD,EACnB,CAACC,CAACA,GAAKsD,EAAQmB,QAAO,CAACK,EAAKC,KAAOD,EAAIlC,QAAQyB,EAASU,IAAKD,IAAM,KACnE,CAAC7E,CAACA,GAAMqD,EAAQtC,KAAI+D,IAAC,CAAM/E,CAACA,GAAKqE,EAASU,OAChD,CAEA,OAAOX,CACT,kBDLO,SAAuBlB,EAAM5C,EAAO6C,GASzC,IARA,IAMI5C,EAAOyE,EAAMC,EAAOnB,EAAMhG,EAN1BsF,EAAOzE,KAAK0E,QAAQD,KAAKF,GACzBI,EAAUF,EAAOA,EAAK/E,OAAOQ,MAAQ,GACrC0E,EAAUH,EAAOA,EAAKhD,IAAegD,EAAKhD,GAAYvB,WAAQ2E,EAC9DC,EAAYN,IAAOrD,EACnBY,EAAI4C,EAAQ3C,OACZC,EAAI,EAGDA,EAAEF,IAAKE,EAGZ,GAFAL,EAAQ+C,EAAQ1C,GAEZ2C,GAAWE,EAAW,CAMxB,IAAc,KAHdwB,GADAD,EAAOA,GAAQ,CAAA,GACFlB,EAAKvD,EAAMuD,OAAS,GAGf,SAOlB,GALAhG,EAAIuC,EAAUC,EAAOC,GACrByE,EAAKlB,GAAQhG,GAAI,IAAOmH,EAIpBnH,GAAsB,IAAjByF,EAAQI,KAAY,OAAO,EACpC,IAAK7F,GAAKmH,IAAU1B,EAAQrE,IAAI4E,GAAMmB,MAAO,OAAO,CACtD,MAKE,GAAIxB,GAJJ3F,EAAIuC,EAAUC,EAAOC,IAIF,OAAOzC,EAO9B,OAAO4C,GAAK+C,CACd,oBG9GO,SAAyBe,EAAO7B,GAOrC,OANK5B,EAAAA,QAAQyD,IACXU,EAAAA,MAAM,uDAEHC,EAAAA,SAASxC,IACZuC,EAAAA,MAAM,yDAEDV,EAAMxD,KAAIW,GAAKyD,EAAAA,OACpBzC,EAAKlC,OAAS,CACZpC,OAAQsE,EAAKlC,OAAOO,KAAIpB,GAAKD,EAAOC,EAAPD,CAAUgC,EAAErB,UACvC,CACFJ,CAACA,GAAcC,EAAawB,EAAErB,QAC7BqC,IACP,qBCjBO,SAA0BO,EAAMmC,EAAMC,EAAOC,GAC9CF,EAAK,GAAGpE,OAASuE,EAAAA,SAASN,EAAAA,MAAM,mEAEpC,MAAM9B,EAAOiC,EAAK,GAAGxG,MAEfgB,EAAQ,OACR4F,EARY,IAQc5F,EAC1B6F,EAVW,IAUatC,GAHnBiC,EAAK1E,QAAU,GAAKgF,EAAAA,KAAKN,GAAMxG,SAM/BiB,GAAc8F,EAAAA,eAAeL,EAAQE,KAC9CF,EAAOE,GAAaH,EAAMO,QAAQzC,GAAM0C,UAAUR,EAAOzF,IAItD+F,EAAAA,eAAeL,EAAQG,KAC1BH,EAAOG,GAAYJ,EAAMO,QAAQzC,GAAM2C,YAE3C","x_google_ignoreList":[0,1,2,3,4,8]}
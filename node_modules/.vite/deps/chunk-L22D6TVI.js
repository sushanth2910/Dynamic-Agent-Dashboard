// node_modules/vega-util/build/vega-util.module.js
function accessor(fn, fields, name2) {
  fn.fields = fields || [];
  fn.fname = name2;
  return fn;
}
function accessorName(fn) {
  return fn == null ? null : fn.fname;
}
function accessorFields(fn) {
  return fn == null ? null : fn.fields;
}
function getter(path) {
  return path.length === 1 ? get1(path[0]) : getN(path);
}
var get1 = (field2) => function(obj) {
  return obj[field2];
};
var getN = (path) => {
  const len = path.length;
  return function(obj) {
    for (let i = 0; i < len; ++i) {
      obj = obj[path[i]];
    }
    return obj;
  };
};
function error(message) {
  throw Error(message);
}
function splitAccessPath(p) {
  const path = [], n = p.length;
  let q = null, b = 0, s = "", i, j, c;
  p = p + "";
  function push() {
    path.push(s + p.substring(i, j));
    s = "";
    i = j + 1;
  }
  for (i = j = 0; j < n; ++j) {
    c = p[j];
    if (c === "\\") {
      s += p.substring(i, j++);
      i = j;
    } else if (c === q) {
      push();
      q = null;
      b = -1;
    } else if (q) {
      continue;
    } else if (i === b && c === '"') {
      i = j + 1;
      q = c;
    } else if (i === b && c === "'") {
      i = j + 1;
      q = c;
    } else if (c === "." && !b) {
      if (j > i) {
        push();
      } else {
        i = j + 1;
      }
    } else if (c === "[") {
      if (j > i) push();
      b = i = j + 1;
    } else if (c === "]") {
      if (!b) error("Access path missing open bracket: " + p);
      if (b > 0) push();
      b = 0;
      i = j + 1;
    }
  }
  if (b) error("Access path missing closing bracket: " + p);
  if (q) error("Access path missing closing quote: " + p);
  if (j > i) {
    j++;
    push();
  }
  return path;
}
function field(field2, name2, opt) {
  const path = splitAccessPath(field2);
  field2 = path.length === 1 ? path[0] : field2;
  return accessor((opt && opt.get || getter)(path), [field2], name2 || field2);
}
var id = field("id");
var identity = accessor((_) => _, [], "identity");
var zero = accessor(() => 0, [], "zero");
var one = accessor(() => 1, [], "one");
var truthy = accessor(() => true, [], "true");
var falsy = accessor(() => false, [], "false");
var DisallowedObjectProperties = new Set(Object.getOwnPropertyNames(Object.prototype));
function log$1(method, level, input) {
  const args = [level].concat([].slice.call(input));
  console[method].apply(console, args);
}
var None = 0;
var Error$1 = 1;
var Warn = 2;
var Info = 3;
var Debug = 4;
function logger(_, method) {
  let handler = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : log$1;
  let level = _ || None;
  return {
    level(_2) {
      if (arguments.length) {
        level = +_2;
        return this;
      } else {
        return level;
      }
    },
    error() {
      if (level >= Error$1) handler(method || "error", "ERROR", arguments);
      return this;
    },
    warn() {
      if (level >= Warn) handler(method || "warn", "WARN", arguments);
      return this;
    },
    info() {
      if (level >= Info) handler(method || "log", "INFO", arguments);
      return this;
    },
    debug() {
      if (level >= Debug) handler(method || "log", "DEBUG", arguments);
      return this;
    }
  };
}
var isArray = Array.isArray;
function isObject(_) {
  return _ === Object(_);
}
var isLegalKey = (key2) => key2 !== "__proto__";
function mergeConfig() {
  for (var _len = arguments.length, configs = new Array(_len), _key = 0; _key < _len; _key++) {
    configs[_key] = arguments[_key];
  }
  return configs.reduce((out, source) => {
    for (const key2 in source) {
      if (key2 === "signals") {
        out.signals = mergeNamed(out.signals, source.signals);
      } else {
        const r = key2 === "legend" ? {
          layout: 1
        } : key2 === "style" ? true : null;
        writeConfig(out, key2, source[key2], r);
      }
    }
    return out;
  }, {});
}
function writeConfig(output, key2, value, recurse) {
  if (!isLegalKey(key2)) return;
  let k, o;
  if (isObject(value) && !isArray(value)) {
    o = isObject(output[key2]) ? output[key2] : output[key2] = {};
    for (k in value) {
      if (recurse && (recurse === true || recurse[k])) {
        writeConfig(o, k, value[k]);
      } else if (isLegalKey(k)) {
        o[k] = value[k];
      }
    }
  } else {
    output[key2] = value;
  }
}
function mergeNamed(a, b) {
  if (a == null) return b;
  const map = {}, out = [];
  function add(_) {
    if (!map[_.name]) {
      map[_.name] = 1;
      out.push(_);
    }
  }
  b.forEach(add);
  a.forEach(add);
  return out;
}
function peek(array2) {
  return array2[array2.length - 1];
}
function toNumber(_) {
  return _ == null || _ === "" ? null : +_;
}
var exp = (sign) => (x) => sign * Math.exp(x);
var log = (sign) => (x) => Math.log(sign * x);
var symlog = (c) => (x) => Math.sign(x) * Math.log1p(Math.abs(x / c));
var symexp = (c) => (x) => Math.sign(x) * Math.expm1(Math.abs(x)) * c;
var pow = (exponent) => (x) => x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
function pan(domain, delta, lift, ground) {
  const d0 = lift(domain[0]), d1 = lift(peek(domain)), dd = (d1 - d0) * delta;
  return [ground(d0 - dd), ground(d1 - dd)];
}
function panLinear(domain, delta) {
  return pan(domain, delta, toNumber, identity);
}
function panLog(domain, delta) {
  var sign = Math.sign(domain[0]);
  return pan(domain, delta, log(sign), exp(sign));
}
function panPow(domain, delta, exponent) {
  return pan(domain, delta, pow(exponent), pow(1 / exponent));
}
function panSymlog(domain, delta, constant2) {
  return pan(domain, delta, symlog(constant2), symexp(constant2));
}
function zoom(domain, anchor, scale, lift, ground) {
  const d0 = lift(domain[0]), d1 = lift(peek(domain)), da = anchor != null ? lift(anchor) : (d0 + d1) / 2;
  return [ground(da + (d0 - da) * scale), ground(da + (d1 - da) * scale)];
}
function zoomLinear(domain, anchor, scale) {
  return zoom(domain, anchor, scale, toNumber, identity);
}
function zoomLog(domain, anchor, scale) {
  const sign = Math.sign(domain[0]);
  return zoom(domain, anchor, scale, log(sign), exp(sign));
}
function zoomPow(domain, anchor, scale, exponent) {
  return zoom(domain, anchor, scale, pow(exponent), pow(1 / exponent));
}
function zoomSymlog(domain, anchor, scale, constant2) {
  return zoom(domain, anchor, scale, symlog(constant2), symexp(constant2));
}
function quarter(date) {
  return 1 + ~~(new Date(date).getMonth() / 3);
}
function utcquarter(date) {
  return 1 + ~~(new Date(date).getUTCMonth() / 3);
}
function array(_) {
  return _ != null ? isArray(_) ? _ : [_] : [];
}
function clampRange(range, min, max) {
  let lo = range[0], hi = range[1], span2;
  if (hi < lo) {
    span2 = hi;
    hi = lo;
    lo = span2;
  }
  span2 = hi - lo;
  return span2 >= max - min ? [min, max] : [lo = Math.min(Math.max(lo, min), max - span2), lo + span2];
}
function isFunction(_) {
  return typeof _ === "function";
}
var DESCENDING = "descending";
function compare(fields, orders, opt) {
  opt = opt || {};
  orders = array(orders) || [];
  const ord = [], get = [], fmap = {}, gen = opt.comparator || comparator;
  array(fields).forEach((f, i) => {
    if (f == null) return;
    ord.push(orders[i] === DESCENDING ? -1 : 1);
    get.push(f = isFunction(f) ? f : field(f, null, opt));
    (accessorFields(f) || []).forEach((_) => fmap[_] = 1);
  });
  return get.length === 0 ? null : accessor(gen(get, ord), Object.keys(fmap));
}
var ascending = (u, v) => (u < v || u == null) && v != null ? -1 : (u > v || v == null) && u != null ? 1 : (v = v instanceof Date ? +v : v, u = u instanceof Date ? +u : u) !== u && v === v ? -1 : v !== v && u === u ? 1 : 0;
var comparator = (fields, orders) => fields.length === 1 ? compare1(fields[0], orders[0]) : compareN(fields, orders, fields.length);
var compare1 = (field2, order) => function(a, b) {
  return ascending(field2(a), field2(b)) * order;
};
var compareN = (fields, orders, n) => {
  orders.push(0);
  return function(a, b) {
    let f, c = 0, i = -1;
    while (c === 0 && ++i < n) {
      f = fields[i];
      c = ascending(f(a), f(b));
    }
    return c * orders[i];
  };
};
function constant(_) {
  return isFunction(_) ? _ : () => _;
}
function debounce(delay, handler) {
  let tid;
  return (e) => {
    if (tid) clearTimeout(tid);
    tid = setTimeout(() => (handler(e), tid = null), delay);
  };
}
function extend(_) {
  for (let x, k, i = 1, len = arguments.length; i < len; ++i) {
    x = arguments[i];
    for (k in x) {
      _[k] = x[k];
    }
  }
  return _;
}
function extent(array2, f) {
  let i = 0, n, v, min, max;
  if (array2 && (n = array2.length)) {
    if (f == null) {
      for (v = array2[i]; i < n && (v == null || v !== v); v = array2[++i]) ;
      min = max = v;
      for (; i < n; ++i) {
        v = array2[i];
        if (v != null) {
          if (v < min) min = v;
          if (v > max) max = v;
        }
      }
    } else {
      for (v = f(array2[i]); i < n && (v == null || v !== v); v = f(array2[++i])) ;
      min = max = v;
      for (; i < n; ++i) {
        v = f(array2[i]);
        if (v != null) {
          if (v < min) min = v;
          if (v > max) max = v;
        }
      }
    }
  }
  return [min, max];
}
function extentIndex(array2, f) {
  const n = array2.length;
  let i = -1, a, b, c, u, v;
  if (f == null) {
    while (++i < n) {
      b = array2[i];
      if (b != null && b >= b) {
        a = c = b;
        break;
      }
    }
    if (i === n) return [-1, -1];
    u = v = i;
    while (++i < n) {
      b = array2[i];
      if (b != null) {
        if (a > b) {
          a = b;
          u = i;
        }
        if (c < b) {
          c = b;
          v = i;
        }
      }
    }
  } else {
    while (++i < n) {
      b = f(array2[i], i, array2);
      if (b != null && b >= b) {
        a = c = b;
        break;
      }
    }
    if (i === n) return [-1, -1];
    u = v = i;
    while (++i < n) {
      b = f(array2[i], i, array2);
      if (b != null) {
        if (a > b) {
          a = b;
          u = i;
        }
        if (c < b) {
          c = b;
          v = i;
        }
      }
    }
  }
  return [u, v];
}
function has(object, property) {
  return Object.hasOwn(object, property);
}
var NULL = {};
function fastmap(input) {
  let obj = {}, test;
  function has$1(key2) {
    return has(obj, key2) && obj[key2] !== NULL;
  }
  const map = {
    size: 0,
    empty: 0,
    object: obj,
    has: has$1,
    get(key2) {
      return has$1(key2) ? obj[key2] : void 0;
    },
    set(key2, value) {
      if (!has$1(key2)) {
        ++map.size;
        if (obj[key2] === NULL) --map.empty;
      }
      obj[key2] = value;
      return this;
    },
    delete(key2) {
      if (has$1(key2)) {
        --map.size;
        ++map.empty;
        obj[key2] = NULL;
      }
      return this;
    },
    clear() {
      map.size = map.empty = 0;
      map.object = obj = {};
    },
    test(_) {
      if (arguments.length) {
        test = _;
        return map;
      } else {
        return test;
      }
    },
    clean() {
      const next = {};
      let size = 0;
      for (const key2 in obj) {
        const value = obj[key2];
        if (value !== NULL && (!test || !test(value))) {
          next[key2] = value;
          ++size;
        }
      }
      map.size = size;
      map.empty = 0;
      map.object = obj = next;
    }
  };
  if (input) Object.keys(input).forEach((key2) => {
    map.set(key2, input[key2]);
  });
  return map;
}
function flush(range, value, threshold, left, right, center) {
  if (!threshold && threshold !== 0) return center;
  const t = +threshold;
  let a = range[0], b = peek(range), l;
  if (b < a) {
    l = a;
    a = b;
    b = l;
  }
  l = Math.abs(value - a);
  const r = Math.abs(b - value);
  return l < r && l <= t ? left : r <= t ? right : center;
}
function inherits(child, parent, members) {
  const proto = child.prototype = Object.create(parent.prototype);
  Object.defineProperty(proto, "constructor", {
    value: child,
    writable: true,
    enumerable: true,
    configurable: true
  });
  return extend(proto, members);
}
function inrange(value, range, left, right) {
  let r0 = range[0], r1 = range[range.length - 1], t;
  if (r0 > r1) {
    t = r0;
    r0 = r1;
    r1 = t;
  }
  left = left === void 0 || left;
  right = right === void 0 || right;
  return (left ? r0 <= value : r0 < value) && (right ? value <= r1 : value < r1);
}
function isBoolean(_) {
  return typeof _ === "boolean";
}
function isDate(_) {
  return Object.prototype.toString.call(_) === "[object Date]";
}
function isIterable(_) {
  return _ && isFunction(_[Symbol.iterator]);
}
function isNumber(_) {
  return typeof _ === "number";
}
function isRegExp(_) {
  return Object.prototype.toString.call(_) === "[object RegExp]";
}
function isString(_) {
  return typeof _ === "string";
}
function key(fields, flat, opt) {
  if (fields) {
    fields = flat ? array(fields).map((f) => f.replace(/\\(.)/g, "$1")) : array(fields);
  }
  const len = fields && fields.length, gen = opt && opt.get || getter, map = (f) => gen(flat ? [f] : splitAccessPath(f));
  let fn;
  if (!len) {
    fn = function() {
      return "";
    };
  } else if (len === 1) {
    const get = map(fields[0]);
    fn = function(_) {
      return "" + get(_);
    };
  } else {
    const get = fields.map(map);
    fn = function(_) {
      let s = "" + get[0](_), i = 0;
      while (++i < len) s += "|" + get[i](_);
      return s;
    };
  }
  return accessor(fn, fields, "key");
}
function lerp(array2, frac) {
  const lo = array2[0], hi = peek(array2), f = +frac;
  return !f ? lo : f === 1 ? hi : lo + f * (hi - lo);
}
var DEFAULT_MAX_SIZE = 1e4;
function lruCache(maxsize) {
  maxsize = +maxsize || DEFAULT_MAX_SIZE;
  let curr, prev, size;
  const clear = () => {
    curr = {};
    prev = {};
    size = 0;
  };
  const update = (key2, value) => {
    if (++size > maxsize) {
      prev = curr;
      curr = {};
      size = 1;
    }
    return curr[key2] = value;
  };
  clear();
  return {
    clear,
    has: (key2) => has(curr, key2) || has(prev, key2),
    get: (key2) => has(curr, key2) ? curr[key2] : has(prev, key2) ? update(key2, prev[key2]) : void 0,
    set: (key2, value) => has(curr, key2) ? curr[key2] = value : update(key2, value)
  };
}
function merge(compare2, array0, array1, output) {
  const n0 = array0.length, n1 = array1.length;
  if (!n1) return array0;
  if (!n0) return array1;
  const merged = output || new array0.constructor(n0 + n1);
  let i0 = 0, i1 = 0, i = 0;
  for (; i0 < n0 && i1 < n1; ++i) {
    merged[i] = compare2(array0[i0], array1[i1]) > 0 ? array1[i1++] : array0[i0++];
  }
  for (; i0 < n0; ++i0, ++i) {
    merged[i] = array0[i0];
  }
  for (; i1 < n1; ++i1, ++i) {
    merged[i] = array1[i1];
  }
  return merged;
}
function repeat(str, reps) {
  let s = "";
  while (--reps >= 0) s += str;
  return s;
}
function pad(str, length, padchar, align) {
  const c = padchar || " ", s = str + "", n = length - s.length;
  return n <= 0 ? s : align === "left" ? repeat(c, n) + s : align === "center" ? repeat(c, ~~(n / 2)) + s + repeat(c, Math.ceil(n / 2)) : s + repeat(c, n);
}
function span(array2) {
  return array2 && peek(array2) - array2[0] || 0;
}
function $(x) {
  return isArray(x) ? "[" + x.map($) + "]" : isObject(x) || isString(x) ? (
    // Output valid JSON and JS source strings.
    // See http://timelessrepo.com/json-isnt-a-javascript-subset
    JSON.stringify(x).replace("\u2028", "\\u2028").replace("\u2029", "\\u2029")
  ) : x;
}
function toBoolean(_) {
  return _ == null || _ === "" ? null : !_ || _ === "false" || _ === "0" ? false : !!_;
}
var defaultParser = (_) => isNumber(_) ? _ : isDate(_) ? _ : Date.parse(_);
function toDate(_, parser) {
  parser = parser || defaultParser;
  return _ == null || _ === "" ? null : parser(_);
}
function toString(_) {
  return _ == null || _ === "" ? null : _ + "";
}
function toSet(_) {
  const s = {}, n = _.length;
  for (let i = 0; i < n; ++i) s[_[i]] = true;
  return s;
}
function truncate(str, length, align, ellipsis) {
  const e = ellipsis != null ? ellipsis : "â€¦", s = str + "", n = s.length, l = Math.max(0, length - e.length);
  return n <= length ? s : align === "left" ? e + s.slice(n - l) : align === "center" ? s.slice(0, Math.ceil(l / 2)) + e + s.slice(n - ~~(l / 2)) : s.slice(0, l) + e;
}
function visitArray(array2, filter, visitor) {
  if (array2) {
    if (filter) {
      const n = array2.length;
      for (let i = 0; i < n; ++i) {
        const t = filter(array2[i]);
        if (t) visitor(t, i, array2);
      }
    } else {
      array2.forEach(visitor);
    }
  }
}

// node_modules/vega-tooltip/build/vega-tooltip.module.js
var name = "vega-tooltip";
var version$1 = "0.35.2";
var description = "A tooltip plugin for Vega-Lite and Vega visualizations.";
var keywords = [
  "vega-lite",
  "vega",
  "tooltip"
];
var repository = {
  type: "git",
  url: "https://github.com/vega/vega-tooltip.git"
};
var author = {
  name: "UW Interactive Data Lab",
  url: "https://idl.cs.washington.edu"
};
var collaborators = [
  "Dominik Moritz",
  "Sira Horradarn",
  "Zening Qu",
  "Kanit Wongsuphasawat",
  "Yuri Astrakhan",
  "Jeffrey Heer"
];
var license = "BSD-3-Clause";
var bugs = {
  url: "https://github.com/vega/vega-tooltip/issues"
};
var homepage = "https://github.com/vega/vega-tooltip#readme";
var main = "build/vega-tooltip.js";
var module = "build/vega-tooltip.module.js";
var unpkg = "build/vega-tooltip.min.js";
var jsdelivr = "build/vega-tooltip.min.js";
var types = "build/src/index.d.ts";
var files = [
  "src",
  "build",
  "types"
];
var scripts = {
  prebuild: "npm run clean && npm run build:style",
  build: "rollup -c",
  "build:style": "./build-style.sh",
  clean: "rimraf build && rimraf src/style.ts",
  "copy:data": "cp -R node_modules/vega-datasets/data examples",
  "copy:build": "cp -R build examples",
  "deploy:gh": "npm run build && npm run copy:build && gh-pages -d examples && npm run clean",
  prepublishOnly: "npm run clean && npm run build",
  preversion: "npm run lint && npm run test",
  serve: "browser-sync start -s -f build examples --serveStatic examples",
  start: "npm run build && concurrently --kill-others -n Server,Rollup 'npm run serve' 'rollup -c -w'",
  pretest: "npm run build:style",
  test: "jest",
  "test:inspect": "node --inspect-brk ./node_modules/.bin/jest --runInBand",
  prepare: "npm run copy:data",
  prettierbase: "prettier '*.{css,scss,html}'",
  format: "eslint . --fix && npm run prettierbase -- --write",
  lint: "eslint . && npm run prettierbase -- --check",
  release: "release-it"
};
var devDependencies = {
  "@babel/core": "^7.26.0",
  "@babel/plugin-proposal-async-generator-functions": "^7.20.7",
  "@babel/plugin-proposal-json-strings": "^7.18.6",
  "@babel/plugin-proposal-object-rest-spread": "^7.20.7",
  "@babel/plugin-proposal-optional-catch-binding": "^7.18.6",
  "@babel/plugin-syntax-dynamic-import": "^7.8.3",
  "@babel/plugin-transform-runtime": "^7.25.9",
  "@babel/preset-env": "^7.26.0",
  "@babel/preset-typescript": "^7.26.0",
  "@release-it/conventional-changelog": "^9.0.2",
  "@rollup/plugin-json": "^6.1.0",
  "@rollup/plugin-node-resolve": "^15.3.0",
  "@rollup/plugin-terser": "^0.4.4",
  "@rollup/plugin-typescript": "^12.1.1",
  "@types/jest": "^29.5.14",
  "@typescript-eslint/eslint-plugin": "^8.13.0",
  "@typescript-eslint/parser": "^8.13.0",
  "browser-sync": "^3.0.3",
  concurrently: "^9.1.0",
  eslint: "^8.46.0",
  "eslint-config-prettier": "^9.1.0",
  "eslint-plugin-jest": "^28.8.3",
  "eslint-plugin-prettier": "^5.2.1",
  "gh-pages": "^6.2.0",
  jest: "^29.7.0",
  "jest-environment-jsdom": "^29.7.0",
  path: "^0.12.7",
  prettier: "^3.3.3",
  "release-it": "^17.10.0",
  rollup: "^4.24.4",
  "rollup-plugin-bundle-size": "^1.0.3",
  sass: "^1.80.6",
  typescript: "~5.6.3",
  "vega-datasets": "^2.9.0",
  "vega-typings": "^1.3.1"
};
var dependencies = {
  "vega-util": "^1.17.2"
};
var optionalDependencies = {
  "@rollup/rollup-linux-x64-gnu": "^4.24.4"
};
var pkg = {
  name,
  version: version$1,
  description,
  keywords,
  repository,
  author,
  collaborators,
  license,
  bugs,
  homepage,
  main,
  module,
  unpkg,
  jsdelivr,
  types,
  files,
  scripts,
  devDependencies,
  dependencies,
  optionalDependencies
};
function formatValue(value, valueToHtml, maxDepth, baseURL) {
  if (isArray(value)) {
    return `[${value.map((v) => valueToHtml(isString(v) ? v : stringify(v, maxDepth))).join(", ")}]`;
  }
  if (isObject(value)) {
    let content = "";
    const { title, image, ...rest } = value;
    if (title) {
      content += `<h2>${valueToHtml(title)}</h2>`;
    }
    if (image) {
      content += `<img src="${new URL(valueToHtml(image), baseURL || location.href).href}">`;
    }
    const keys = Object.keys(rest);
    if (keys.length > 0) {
      content += "<table>";
      for (const key2 of keys) {
        let val = rest[key2];
        if (val === void 0) {
          continue;
        }
        if (isObject(val)) {
          val = stringify(val, maxDepth);
        }
        content += `<tr><td class="key">${valueToHtml(key2)}</td><td class="value">${valueToHtml(val)}</td></tr>`;
      }
      content += `</table>`;
    }
    return content || "{}";
  }
  return valueToHtml(value);
}
function replacer(maxDepth) {
  const stack = [];
  return function(key2, value) {
    if (typeof value !== "object" || value === null) {
      return value;
    }
    const pos = stack.indexOf(this) + 1;
    stack.length = pos;
    if (stack.length > maxDepth) {
      return "[Object]";
    }
    if (stack.indexOf(value) >= 0) {
      return "[Circular]";
    }
    stack.push(value);
    return value;
  };
}
function stringify(obj, maxDepth) {
  return JSON.stringify(obj, replacer(maxDepth));
}
var defaultStyle = `#vg-tooltip-element {
  visibility: hidden;
  padding: 8px;
  position: fixed;
  z-index: 1000;
  font-family: sans-serif;
  font-size: 11px;
  border-radius: 3px;
  box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
  /* The default theme is the light theme. */
  background-color: rgba(255, 255, 255, 0.95);
  border: 1px solid #d9d9d9;
  color: black;
}
#vg-tooltip-element.visible {
  visibility: visible;
}
#vg-tooltip-element h2 {
  margin-top: 0;
  margin-bottom: 10px;
  font-size: 13px;
}
#vg-tooltip-element table {
  border-spacing: 0;
}
#vg-tooltip-element table tr {
  border: none;
}
#vg-tooltip-element table tr td {
  overflow: hidden;
  text-overflow: ellipsis;
  padding-top: 2px;
  padding-bottom: 2px;
}
#vg-tooltip-element table tr td.key {
  color: #808080;
  max-width: 150px;
  text-align: right;
  padding-right: 4px;
}
#vg-tooltip-element table tr td.value {
  display: block;
  max-width: 300px;
  max-height: 7em;
  text-align: left;
}
#vg-tooltip-element.dark-theme {
  background-color: rgba(32, 32, 32, 0.9);
  border: 1px solid #f5f5f5;
  color: white;
}
#vg-tooltip-element.dark-theme td.key {
  color: #bfbfbf;
}
`;
var EL_ID = "vg-tooltip-element";
var DEFAULT_OPTIONS = {
  offsetX: 10,
  offsetY: 10,
  id: EL_ID,
  styleId: "vega-tooltip-style",
  theme: "light",
  disableDefaultStyle: false,
  sanitize: escapeHTML,
  maxDepth: 2,
  formatTooltip: formatValue,
  baseURL: "",
  anchor: "cursor",
  position: ["top", "bottom", "left", "right", "top-left", "top-right", "bottom-left", "bottom-right"]
};
function escapeHTML(value) {
  return String(value).replace(/&/g, "&amp;").replace(/</g, "&lt;");
}
function createDefaultStyle(id2) {
  if (!/^[A-Za-z]+[-:.\w]*$/.test(id2)) {
    throw new Error("Invalid HTML ID");
  }
  return defaultStyle.toString().replace(EL_ID, id2);
}
function calculatePositionRelativeToCursor(event, tooltipBox, { offsetX, offsetY }) {
  const positions = getPositions({ x1: event.clientX, x2: event.clientX, y1: event.clientY, y2: event.clientY }, tooltipBox, offsetX, offsetY);
  const postionArr = ["bottom-right", "bottom-left", "top-right", "top-left"];
  for (const p of postionArr) {
    if (tooltipIsInViewport(positions[p], tooltipBox)) {
      return positions[p];
    }
  }
  return positions["top-left"];
}
function calculatePositionRelativeToMark(handler, event, item, tooltipBox, options) {
  const { position, offsetX, offsetY } = options;
  const containerBox = handler._el.getBoundingClientRect();
  const origin = handler._origin;
  const markBounds = getMarkBounds(containerBox, origin, item);
  const positions = getPositions(markBounds, tooltipBox, offsetX, offsetY);
  const positionArr = Array.isArray(position) ? position : [position];
  for (const p of positionArr) {
    if (tooltipIsInViewport(positions[p], tooltipBox) && !mouseIsOnTooltip(event, positions[p], tooltipBox)) {
      return positions[p];
    }
  }
  return calculatePositionRelativeToCursor(event, tooltipBox, options);
}
function getMarkBounds(containerBox, origin, item) {
  const markBounds = item.isVoronoi ? item.datum.bounds : item.bounds;
  let left = containerBox.left + origin[0] + markBounds.x1;
  let top = containerBox.top + origin[1] + markBounds.y1;
  let parentItem = item;
  while (parentItem.mark.group) {
    parentItem = parentItem.mark.group;
    left += parentItem.x ?? 0;
    top += parentItem.y ?? 0;
  }
  const markWidth = markBounds.x2 - markBounds.x1;
  const markHeight = markBounds.y2 - markBounds.y1;
  return {
    x1: left,
    x2: left + markWidth,
    y1: top,
    y2: top + markHeight
  };
}
function getPositions(markBounds, tooltipBox, offsetX, offsetY) {
  const xc = (markBounds.x1 + markBounds.x2) / 2;
  const yc = (markBounds.y1 + markBounds.y2) / 2;
  const left = markBounds.x1 - tooltipBox.width - offsetX;
  const center = xc - tooltipBox.width / 2;
  const right = markBounds.x2 + offsetX;
  const top = markBounds.y1 - tooltipBox.height - offsetY;
  const middle = yc - tooltipBox.height / 2;
  const bottom = markBounds.y2 + offsetY;
  const positions = {
    top: { x: center, y: top },
    bottom: { x: center, y: bottom },
    left: { x: left, y: middle },
    right: { x: right, y: middle },
    "top-left": { x: left, y: top },
    "top-right": { x: right, y: top },
    "bottom-left": { x: left, y: bottom },
    "bottom-right": { x: right, y: bottom }
  };
  return positions;
}
function tooltipIsInViewport(position, tooltipBox) {
  return position.x >= 0 && position.y >= 0 && position.x + tooltipBox.width <= window.innerWidth && position.y + tooltipBox.height <= window.innerHeight;
}
function mouseIsOnTooltip(event, position, tooltipBox) {
  return event.clientX >= position.x && event.clientX <= position.x + tooltipBox.width && event.clientY >= position.y && event.clientY <= position.y + tooltipBox.height;
}
var Handler = class {
  /**
   * Create the tooltip handler and initialize the element and style.
   *
   * @param options Tooltip Options
   */
  constructor(options) {
    this.options = { ...DEFAULT_OPTIONS, ...options };
    const elementId = this.options.id;
    this.el = null;
    this.call = this.tooltipHandler.bind(this);
    if (!this.options.disableDefaultStyle && !document.getElementById(this.options.styleId)) {
      const style = document.createElement("style");
      style.setAttribute("id", this.options.styleId);
      style.innerHTML = createDefaultStyle(elementId);
      const head = document.head;
      if (head.childNodes.length > 0) {
        head.insertBefore(style, head.childNodes[0]);
      } else {
        head.appendChild(style);
      }
    }
  }
  /**
   * The tooltip handler function.
   */
  tooltipHandler(handler, event, item, value) {
    this.el = document.getElementById(this.options.id);
    if (!this.el) {
      this.el = document.createElement("div");
      this.el.setAttribute("id", this.options.id);
      this.el.classList.add("vg-tooltip");
      const tooltipContainer = document.fullscreenElement ?? document.body;
      tooltipContainer.appendChild(this.el);
    }
    if (value == null || value === "") {
      this.el.classList.remove("visible", `${this.options.theme}-theme`);
      return;
    }
    this.el.innerHTML = this.options.formatTooltip(value, this.options.sanitize, this.options.maxDepth, this.options.baseURL);
    this.el.classList.add("visible", `${this.options.theme}-theme`);
    const { x, y } = this.options.anchor === "mark" ? calculatePositionRelativeToMark(handler, event, item, this.el.getBoundingClientRect(), this.options) : calculatePositionRelativeToCursor(event, this.el.getBoundingClientRect(), this.options);
    this.el.style.top = `${y}px`;
    this.el.style.left = `${x}px`;
  }
};
var version = pkg.version;
function index(view, opt) {
  const handler = new Handler(opt);
  view.tooltip(handler.call).run();
  return handler;
}

export {
  accessor,
  accessorName,
  accessorFields,
  error,
  splitAccessPath,
  field,
  id,
  identity,
  zero,
  one,
  truthy,
  falsy,
  DisallowedObjectProperties,
  None,
  Error$1,
  Warn,
  Info,
  Debug,
  logger,
  isArray,
  isObject,
  mergeConfig,
  writeConfig,
  peek,
  toNumber,
  panLinear,
  panLog,
  panPow,
  panSymlog,
  zoomLinear,
  zoomLog,
  zoomPow,
  zoomSymlog,
  quarter,
  utcquarter,
  array,
  clampRange,
  isFunction,
  compare,
  ascending,
  constant,
  debounce,
  extend,
  extent,
  extentIndex,
  has,
  fastmap,
  flush,
  inherits,
  inrange,
  isBoolean,
  isDate,
  isIterable,
  isNumber,
  isRegExp,
  isString,
  key,
  lerp,
  lruCache,
  merge,
  repeat,
  pad,
  span,
  $,
  toBoolean,
  toDate,
  toString,
  toSet,
  truncate,
  visitArray,
  formatValue,
  replacer,
  stringify,
  DEFAULT_OPTIONS,
  escapeHTML,
  createDefaultStyle,
  calculatePositionRelativeToCursor,
  calculatePositionRelativeToMark,
  getMarkBounds,
  getPositions,
  tooltipIsInViewport,
  mouseIsOnTooltip,
  Handler,
  version,
  index
};
//# sourceMappingURL=chunk-L22D6TVI.js.map
